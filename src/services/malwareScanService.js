import NodeClam from 'clamscan';
import { fileTypeFromBuffer } from 'file-type';
import fs from 'fs/promises';
import crypto from 'crypto';
import path from 'path';
import logger from '../utils/logger.js';
import config from '../config/environment.js';

/**
 * Malware Scanning Service
 * Uses ClamAV for virus/malware detection in uploaded files
 */

class MalwareScanService {
  constructor() {
    this.clamAV = null;
    this.isAvailable = false;
    this.initializeScanner();
  }

  /**
   * Initialize ClamAV scanner
   */
  async initializeScanner() {
    try {
      const clamConfig = {
        removeInfected: false, // Don't auto-delete, let us handle it
        quarantineInfected: false,
        scanLog: null,
        debugMode: config.nodeEnv === 'development',
        clamdscan: {
          socket: process.platform === 'win32' ? null : '/var/run/clamav/clamd.ctl',
          host: config.clamav?.host || 'localhost',
          port: config.clamav?.port || 3310,
          timeout: 60000,
          localFallback: true, // Try local scanner if daemon not available
        },
        preference: 'clamdscan', // Prefer daemon for performance
      };

      this.clamAV = await new NodeClam().init(clamConfig);
      this.isAvailable = true;

      logger.info('‚úÖ ClamAV malware scanner initialized successfully');
    } catch (error) {
      this.isAvailable = false;
      logger.warn('‚ö†Ô∏è  ClamAV not available. File scanning will use fallback validation only.');
      logger.warn(`ClamAV initialization error: ${error.message}`);
    }
  }

  /**
   * Check if ClamAV is available
   */
  isScannerAvailable() {
    return this.isAvailable;
  }

  /**
   * Scan a file for malware
   * @param {string} filePath - Path to file to scan
   * @returns {Promise<Object>} - Scan result
   */
  async scanFile(filePath) {
    const startTime = Date.now();

    try {
      // Validate file exists
      await fs.access(filePath);

      // Get file stats
      const stats = await fs.stat(filePath);
      const fileSize = stats.size;

      logger.info(`Scanning file: ${path.basename(filePath)} (${fileSize} bytes)`);

      // If ClamAV not available, use fallback validation
      if (!this.isAvailable) {
        return await this.fallbackValidation(filePath, fileSize);
      }

      // Scan with ClamAV
      const { isInfected, viruses, file } = await this.clamAV.isInfected(filePath);

      const scanTime = Date.now() - startTime;

      if (isInfected) {
        logger.error(`ü¶† MALWARE DETECTED: ${file} - Viruses: ${viruses.join(', ')}`);

        return {
          safe: false,
          infected: true,
          viruses: viruses,
          file: path.basename(filePath),
          scanTime,
          scanner: 'ClamAV',
          action: 'rejected',
        };
      }

      logger.info(`‚úÖ File scan clean: ${path.basename(filePath)} (${scanTime}ms)`);

      return {
        safe: true,
        infected: false,
        viruses: [],
        file: path.basename(filePath),
        scanTime,
        scanner: 'ClamAV',
      };
    } catch (error) {
      logger.error('File scan error:', error);

      return {
        safe: false,
        infected: false,
        error: error.message,
        file: path.basename(filePath),
        scanTime: Date.now() - startTime,
        scanner: 'ClamAV',
        action: 'error',
      };
    }
  }

  /**
   * Scan file buffer (for memory-based scanning)
   * @param {Buffer} buffer - File buffer
   * @param {string} filename - Original filename
   * @returns {Promise<Object>} - Scan result
   */
  async scanBuffer(buffer, filename) {
    const startTime = Date.now();

    try {
      logger.info(`Scanning buffer: ${filename} (${buffer.length} bytes)`);

      // If ClamAV not available, use fallback
      if (!this.isAvailable) {
        return await this.fallbackBufferValidation(buffer, filename);
      }

      // Scan buffer with ClamAV
      const { isInfected, viruses } = await this.clamAV.scanBuffer(buffer);

      const scanTime = Date.now() - startTime;

      if (isInfected) {
        logger.error(`ü¶† MALWARE DETECTED in buffer: ${filename} - Viruses: ${viruses.join(', ')}`);

        return {
          safe: false,
          infected: true,
          viruses: viruses,
          file: filename,
          scanTime,
          scanner: 'ClamAV',
          action: 'rejected',
        };
      }

      logger.info(`‚úÖ Buffer scan clean: ${filename} (${scanTime}ms)`);

      return {
        safe: true,
        infected: false,
        viruses: [],
        file: filename,
        scanTime,
        scanner: 'ClamAV',
      };
    } catch (error) {
      logger.error('Buffer scan error:', error);

      return {
        safe: false,
        infected: false,
        error: error.message,
        file: filename,
        scanTime: Date.now() - startTime,
        scanner: 'ClamAV',
        action: 'error',
      };
    }
  }

  /**
   * Fallback validation when ClamAV is not available
   * Performs basic security checks
   */
  async fallbackValidation(filePath, fileSize) {
    logger.info('Using fallback validation (ClamAV not available)');

    const checks = {
      safe: true,
      infected: false,
      warnings: [],
      file: path.basename(filePath),
      scanner: 'Fallback',
    };

    // Check file size (reject very large files)
    const maxSize = 100 * 1024 * 1024; // 100MB
    if (fileSize > maxSize) {
      checks.safe = false;
      checks.warnings.push(`File too large: ${fileSize} bytes (max: ${maxSize})`);
    }

    // Check file extension
    const ext = path.extname(filePath).toLowerCase();
    const dangerousExtensions = ['.exe', '.bat', '.cmd', '.com', '.scr', '.vbs', '.js', '.jar', '.app'];

    if (dangerousExtensions.includes(ext)) {
      checks.safe = false;
      checks.warnings.push(`Dangerous file extension: ${ext}`);
    }

    // Check file content (magic bytes)
    try {
      const buffer = await fs.readFile(filePath);
      const fileType = await fileTypeFromBuffer(buffer);

      if (fileType) {
        // Check if extension matches actual file type
        const expectedExt = `.${fileType.ext}`;
        if (ext && ext !== expectedExt) {
          checks.warnings.push(`Extension mismatch: ${ext} vs actual ${expectedExt}`);
        }

        // Block executable file types
        const dangerousMimes = [
          'application/x-msdownload',
          'application/x-executable',
          'application/x-mach-binary',
        ];

        if (dangerousMimes.includes(fileType.mime)) {
          checks.safe = false;
          checks.warnings.push(`Dangerous MIME type: ${fileType.mime}`);
        }
      }

      // Check for suspicious patterns in content
      const content = buffer.toString('utf8', 0, Math.min(buffer.length, 1024)); // First 1KB
      const suspiciousPatterns = [
        /<script[^>]*>[\s\S]*?<\/script>/i,
        /eval\(/i,
        /exec\(/i,
        /system\(/i,
        /\$_GET\[/i,
        /\$_POST\[/i,
      ];

      for (const pattern of suspiciousPatterns) {
        if (pattern.test(content)) {
          checks.warnings.push(`Suspicious pattern detected: ${pattern}`);
        }
      }
    } catch (error) {
      logger.error('Fallback validation error:', error);
      checks.warnings.push(`Validation error: ${error.message}`);
    }

    return checks;
  }

  /**
   * Fallback buffer validation
   */
  async fallbackBufferValidation(buffer, filename) {
    logger.info('Using fallback buffer validation (ClamAV not available)');

    const checks = {
      safe: true,
      infected: false,
      warnings: [],
      file: filename,
      scanner: 'Fallback',
    };

    // Check buffer size
    const maxSize = 100 * 1024 * 1024; // 100MB
    if (buffer.length > maxSize) {
      checks.safe = false;
      checks.warnings.push(`File too large: ${buffer.length} bytes (max: ${maxSize})`);
    }

    // Check file extension
    const ext = path.extname(filename).toLowerCase();
    const dangerousExtensions = ['.exe', '.bat', '.cmd', '.com', '.scr', '.vbs', '.js', '.jar', '.app'];

    if (dangerousExtensions.includes(ext)) {
      checks.safe = false;
      checks.warnings.push(`Dangerous file extension: ${ext}`);
    }

    // Check file type from buffer
    try {
      const fileType = await fileTypeFromBuffer(buffer);

      if (fileType) {
        const expectedExt = `.${fileType.ext}`;
        if (ext && ext !== expectedExt) {
          checks.warnings.push(`Extension mismatch: ${ext} vs actual ${expectedExt}`);
        }
      }
    } catch (error) {
      checks.warnings.push(`File type detection error: ${error.message}`);
    }

    return checks;
  }

  /**
   * Calculate file hash (for tracking known malware)
   * @param {string} filePath - Path to file
   * @returns {Promise<string>} - SHA256 hash
   */
  async calculateFileHash(filePath) {
    try {
      const buffer = await fs.readFile(filePath);
      const hash = crypto.createHash('sha256').update(buffer).digest('hex');
      return hash;
    } catch (error) {
      logger.error('Hash calculation error:', error);
      return null;
    }
  }

  /**
   * Get ClamAV version info
   */
  async getVersion() {
    if (!this.isAvailable) {
      return { available: false };
    }

    try {
      const version = await this.clamAV.getVersion();
      return {
        available: true,
        version,
      };
    } catch (error) {
      return {
        available: false,
        error: error.message,
      };
    }
  }

  /**
   * Update virus definitions (requires ClamAV freshclam)
   */
  async updateDefinitions() {
    logger.info('Virus definitions should be updated via freshclam service');
    return {
      success: false,
      message: 'Use system freshclam service to update definitions',
    };
  }

  /**
   * Quarantine infected file
   * @param {string} filePath - Path to infected file
   */
  async quarantineFile(filePath) {
    try {
      const quarantineDir = path.join(process.cwd(), 'quarantine');

      // Ensure quarantine directory exists
      await fs.mkdir(quarantineDir, { recursive: true });

      // Generate unique name for quarantined file
      const timestamp = Date.now();
      const hash = crypto.randomBytes(8).toString('hex');
      const quarantinePath = path.join(quarantineDir, `${timestamp}-${hash}-${path.basename(filePath)}.quarantine`);

      // Move file to quarantine
      await fs.rename(filePath, quarantinePath);

      logger.warn(`üîí File quarantined: ${quarantinePath}`);

      return {
        success: true,
        quarantinePath,
      };
    } catch (error) {
      logger.error('Quarantine error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Delete infected file permanently
   * @param {string} filePath - Path to file
   */
  async deleteFile(filePath) {
    try {
      await fs.unlink(filePath);
      logger.warn(`üóëÔ∏è  Infected file deleted: ${filePath}`);

      return {
        success: true,
        message: 'File deleted',
      };
    } catch (error) {
      logger.error('Delete error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }
}

// Export singleton instance
const malwareScanService = new MalwareScanService();

export default malwareScanService;
